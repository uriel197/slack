const app = require("./src/app");
const mongoose = require("mongoose");

const url = process.env.MONGO_URL || "mongodb://127.0.0.1:27017/local";
const port = process.env.PORT || 3000;

mongoose.connect(url);
app.listen(port, () => console.log(`server connected on port ${port}...`));

process.on("unhandledRejection", (e) => {
  console.log(e.message);
  process.exit(1);
});

/*
=============================================
        COMMENTS - COMMENTS - COMMENTS
=============================================

which file serves as the entry point?
In a typical Node.js application, server.js is the entry point for running the server. It is "called" (executed) when you use a command like:

node server.js
or when a script in package.json specifies it as the file to execute, "npm start":

"scripts": {
  "start": "node server.js",
  "dev": "nodemon server.js"
}

If one file imports another, the imported fileâ€™s code executes when the import happens. For example:

// server.js
require("./app.js"); // This will run app.js first
console.log("server.js is running");
If you run node server.js, the output will indicate that app.js executed before the rest of server.js.

The "main": "index.js" field in your package.json specifies the entry point of your module when it's required or imported by other files or packages.

 Where Webpack Comes In:
Webpack is not automatically run by npm start.
Webpack is a build tool that processes your frontend files (JavaScript, CSS, HTML) and generates a production-ready bundle. This is usually done before deploying the server or before running the application if you're in development.
Webpack Build Process:
When you run Webpack (via webpack or a script in package.json like npm run build):

Webpack starts from the entry file specified in webpack.config.js:
javascript
Copy code
entry: path.join(__dirname, "src", "public", "components", "main.js")
This is your frontend's starting point.
Webpack follows all import/require statements to bundle the entire dependency graph into bundle.js.
It outputs:
A JavaScript bundle (bundle.js) in the dist directory.
A processed CSS file (main.css).
A generated HTML file (based on index.html).
The output files (bundle.js, main.css) are then served as static assets by your backend.

Summary of File Execution:
Backend Execution (when npm start runs):

server.js runs first.
It imports and uses app.js.
Frontend Build (Webpack):

Webpack processes your frontend files (main.js), but only when you run Webpack (e.g., npm run build or npx webpack).
Webpack's output (bundle.js, main.css) is served by server.js.
Complete Flow:

You typically run Webpack first to build the frontend.
Then, start the backend with npm start, which serves the static assets generated by Webpack.
*/
